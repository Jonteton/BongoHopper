// This is the Path class.
// Path generates a set of Points from the Points class to then draw the curves between
// The Path is proceduraly generated, meaining that the height, depth etc of curves is randomly generated.
// NOTE:
// The points have a fixed X-distane between them, this is a requirement for tracking bird position

import Point from "./point.js"
export default class Path {
    constructor(originX, originY, canvasWidth, canvasHeight, world, pointStepSize) {
        this.originX = originX;
        this.originY = originY;
        this.canvasWidth = canvasWidth
        this.canvasHeight = canvasHeight
        this.game_Environment = world;
        this.pointStepSize = pointStepSize

        this.originPoint = new Point(this.originX, this.originY)
        this.points = [this.originPoint]

        //Remeber Y-axis goes downwards, so values are reversed
        this.maxHeight = 200
        this.minHeight = 100
        this.lowSlopeCoefficient = 2
        this.lowSlopeTop = Math.floor(Math.random() * (this.minHeight - this.maxHeight) + this.maxHeight)


        this.enablePointGeneration = true
        this.enableHill = true
        this.up = true

        //Below variable has to be changed, currently not randomized
        this.randomizedBottomHeight = this.canvasHeight - 50

        this.minvelocityX = 10
        this.velocityX = this.minvelocityX

        this.accelerationX = 0
        this.maxAcceleration = 6

        this.preLoadConstant = 150
        this.preLoadLimitX = this.canvasWidth + this.preLoadConstant

    }

    createPath() {
        // Handles how the path is generated
        this.updatePath()
        this.generatePath()
        this.drawPath()
    }

    updatePath(){
        // Updates the points on the path, removes the ones that are offscreen in terms of X-value
        // The other points are moved forward according to the velocity
        let offScreen = -40
        for(let i = 0; i < this.points.length; i++){
            this.points[i].x -= this.velocityX

            if(this.points[i].x < offScreen){
              this.points.splice(0, i)
            }
        }
    }

    generatePath(){
        // Creates the "Path Points"
        let currentPointX = this.points[this.points.length - 1].x
        let currentPointY = this.points[this.points.length - 1].y
        let nextPointX = currentPointX + this.pointStepSize

        if(this.points.length > 2 && nextPointX < this.preLoadLimitX){
            // Points already exist, create one after the last one
            this.proceduralGenerator(currentPointX, currentPointY, nextPointX)
        } 
        if(this.points.length == 1) {
            // Points doesnt exist, generate new
            this.initializePath()
        }
    }

    initializePath() {
        //Creates the path when game is first started (Happends once)
        let startingHeight = this.originY
        let nextPointX = null
        while(this.points[this.points.length - 1].x < this.preLoadLimitX){
            nextPointX = this.points[this.points.length - 1].x + this.pointStepSize
            this.points.push(new Point(nextPointX, startingHeight))
        }
    }

    proceduralGenerator(currentPointX, currentPointY, nextPointX){
        // Generates random hills on the path
        // The randomly generated variables are height and angle
        this.createLowHill(currentPointX, currentPointY, nextPointX)
    }

    createLowHill(currentPointX, currentPointY, nextPointX){
        let nextPointY = null
        if(this.up == true){
            // Slope going upwards?
            if(this.lowSlopeCoefficient < 12){
                // Dummy variable for trying to make a nice slope !!CHANGE THIS!! (is bad)
                this.lowSlopeCoefficient = this.lowSlopeCoefficient*1.03
            }
            nextPointY = this.nextPointY(currentPointX, currentPointY, nextPointX, Math.PI/this.lowSlopeCoefficient, "upwards")

            if(nextPointY < this.lowSlopeTop){
                // Have we reached the top?
                this.up = false
                this.generateNewTop("LowHill")
            }
        } if (this.up == false){
            // Slope going downwards?
            this.lowSlopeCoefficient = this.lowSlopeCoefficient*0.97
            nextPointY = this.nextPointY(currentPointX, currentPointY, nextPointX, Math.PI/-this.lowSlopeCoefficient, "downwards")

            if(nextPointY > this.randomizedBottomHeight){
                //Have we reached the bottom?
                this.up = true
                this.lowSlopeCoefficient = 2
            }
        }
        this.points.push(new Point(nextPointX, nextPointY))

    }

    drawPath() {
        // This function draws the path to the screen that was generated by generatePath
        this.game_Environment.strokeStyle = "red";
        this.game_Environment.lineWidth = 3
        
        this.game_Environment.moveTo(this.points[0].x, this.points[0].y)
        this.game_Environment.beginPath();
        for(let i = this.points.length - 1; i > 0; i--){
            if(i-1 == 0){
                //Avoid getting index out of range
                break;
            }
            this.game_Environment.lineTo(this.points[i-1].x, this.points[i-1].y)
        }
        this.game_Environment.stroke()
    }   

    //Below are math formulas
    nextPointY(p1x, p1y, p2x, angle, direction){
        //Identifies the y-position of the next point (p2)
        let deltaHeight = 0
        let heightMultiplier = 1
        if(direction == "upwards"){
            deltaHeight = heightMultiplier*Math.sin(angle)*(p1x-p2x)
        } else if (direction == "downwards"){
            deltaHeight = heightMultiplier*Math.sin(angle)*(p1x-p2x)
        }
        let p2y = deltaHeight + p1y
        return p2y
    }

    increaseVelocity(){
        if(this.accelerationX < this.maxAcceleration){
        }
        this.updatePath()
    }

    generateNewTop(hillType){
        if(hillType == "LowHill"){
            this.lowSlopeTop = Math.floor(Math.random() * (this.maxHeight - 100) + 100)
        }
    }
}