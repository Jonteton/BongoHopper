// This is the Path class.
// Path generates a set of Points from the Points class to then draw the curves between
// The Path is proceduraly generated, meaining that the height, depth etc of curves is randomly generated.
// NOTE:
// The points have a fixed X-distane between them, this is a requirement for tracking bird position

import Point from "./point.js"
export default class Path {
    constructor(originX, originY, canvasWidth, canvasHeight, world, pointStepSize) {
        this.originX = originX;
        this.originY = originY;
        this.canvasWidth = canvasWidth
        this.canvasHeight = canvasHeight
        this.game_Environment = world;
        this.pointStepSize = pointStepSize

        this.originPoint = new Point(this.originX, this.originY)
        this.points = [this.originPoint]

        this.minAmplitude = 0.5
        this.maxAmplitude = 1
        this.hillAmplitude = 1

        this.angleInDegrees = null

        //Below variable has to be changed, currently not randomized
        this.randomizedBottomHeight = this.canvasHeight - 50

        this.minvelocityX = 8
        this.velocityX = this.minvelocityX

        this.accelerationX = 0
        this.maxVelocity = 15

        this.preLoadConstant = 150
        this.preLoadLimitX = this.canvasWidth + this.preLoadConstant

    }

    createPath() {
        // Handles how the path is generated
        this.updatePath()
        this.generatePath()
        this.drawPath()
    }

    updatePath(){
        // Updates the points on the path, removes the ones that are offscreen in terms of X-value
        // The other points are moved forward according to the velocity
        let offScreen = -500
        for(let i = 0; i < this.points.length; i++){
            this.points[i].x -= this.velocityX

            if(this.points[i].x < offScreen){
              this.points.splice(0, i)
            }
        }
    }

    generatePath(){
        // Creates the "Path Points"
        let currentPointX = this.points[this.points.length - 1].x
        let currentPointY = this.points[this.points.length - 1].y
        let nextPointX = currentPointX + this.pointStepSize

        if(this.points.length > 2 && nextPointX < this.preLoadLimitX){
            // Points already exist, create one after the last one
            while(nextPointX < this.preLoadLimitX){
                this.proceduralGenerator(currentPointX, currentPointY, nextPointX)
                currentPointX = this.points[this.points.length - 1].x
                currentPointY = this.points[this.points.length - 1].y
                nextPointX = currentPointX + this.pointStepSize
            }
        } 
        if(this.points.length == 1) {
            // Points doesnt exist, generate new
            this.initializePath()
        }
    }

    initializePath() {
        //Creates the path when game is first started (Happends once)
        let startingHeight = this.originY
        let nextPointX = null
        while(this.points[this.points.length - 1].x < this.preLoadLimitX){
            nextPointX = this.points[this.points.length - 1].x + this.pointStepSize
            this.points.push(new Point(nextPointX, startingHeight))
        }
    }

    proceduralGenerator(currentPointX, currentPointY, nextPointX){
        // Generates random hills on the path
        // The randomly generated variables are height and angle

        this.generateHill(currentPointX, currentPointY, nextPointX)
    }

    generateHill(currentPointX, currentPointY, nextPointX){
        let nextPointY = null
        let angleInRadians = null

        this.angleInDegrees += 1
        angleInRadians = this.angleInDegrees*(Math.PI/180)
        if (this.angleInDegrees >= 360){
            this.angleInDegrees = 0
            this.hillAmplitude = this.generateAmplitude()
        }
        nextPointY = this.nextPointY(currentPointX, currentPointY, nextPointX, angleInRadians, this.angleInDegrees)
        this.points.push(new Point(nextPointX, nextPointY))

    }

    drawPath() {
        // This function draws the path to the screen that was generated by generatePath
        this.game_Environment.strokeStyle = "red";
        this.game_Environment.lineWidth = 3
        
        this.game_Environment.moveTo(this.points[0].x, this.points[0].y)
        this.game_Environment.beginPath();
        for(let i = this.points.length - 1; i > 0; i--){
            if(i-1 == 0){
                //Avoid getting index out of range
                break;
            }
            this.game_Environment.lineTo(this.points[i-1].x, this.points[i-1].y)
        }
        this.game_Environment.stroke()
    }   

    //Below are math formulas
    nextPointY(p1x, p1y, p2x, angle){
        //Identifies the y-position of the next point (p2)
        let deltaHeight = 0
        deltaHeight = this.hillAmplitude*Math.sin(angle)*(p1x-p2x)
        let p2y = deltaHeight + p1y
        return p2y
    }

    generateNewTop(hillType){
        if(hillType == "LowHill"){
            this.lowSlopeTop = Math.floor(Math.random() * (this.maxHeight - 150) + 25)
        }
    }

    generateAmplitude(){
        //Generates a value between min and max amplitude
        let amplitude = Math.random() * (this.maxAmplitude - this.minAmplitude) + this.minAmplitude
        return amplitude
    }

}