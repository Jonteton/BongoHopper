import Point from "./point.js"
export default class Path {
    constructor(originX, originY, canvasWidth, canvasHeight, world, pointStepSize) {
        this.originX = originX;
        this.originY = originY;
        this.canvasWidth = canvasWidth
        this.canvasHeight = canvasHeight
        this.game_Environment = world;
        this.pointStepSize = pointStepSize

        this.originPoint = new Point(this.originX, this.originY)
        this.points = [this.originPoint]

        //Remeber Y-axis goes downwards, so values are reversed
        this.maxHeight = 200
        this.minHeight = 100
        this.lowSlopeCoefficient = 2
        this.lowSlopeTop = Math.floor(Math.random() * (this.minHeight - this.maxHeight) + this.maxHeight)


        this.enablePointGeneration = true
        this.enableHill = true
        this.up = true

        this.friction = 0.004
        this.velocityX = 0
        this.accelerationX = 0
        this.maxAcceleration = 6

    }

    createPath() {
        this.updatePath()
        this.generatePath()
        this.drawPath()
    }

    updatePath(){
        this.applyFriction()
        for(let i = 0; i < this.points.length; i++){
            this.points[i].x -= this.velocityX
            if(this.points[i].x < -70){
              //If point off screen, remove
              this.points.splice(0, i)
            }
        }
    }

    generatePath(){
        // This function creates the points that when drawn creates the path
        // Could improve how first points are generated
        let currentPointX = this.points[this.points.length - 1].x
        let currentPointY = this.points[this.points.length - 1].y
        let nextPointX = currentPointX + this.pointStepSize

        if(this.points.length > 2 && nextPointX < this.canvasWidth + 2* this.pointStepSize){
            // Points already exist, create one after the last one
            this.proceduralGenerator(currentPointX, currentPointY, nextPointX)
        } 
        if(this.points.length == 1) {
            // Points doesnt exist, generate new
            this.initializePath()
        }
    }

    initializePath() {
        //Creates the path when game is first started
        let startingHeight = this.originY
        while(this.points[this.points.length - 1].x < this.canvasWidth + 2*this.pointStepSize){
            let nextPointX = this.points[this.points.length - 1].x + this.pointStepSize
            this.points.push(new Point(nextPointX, startingHeight))
        }
    }

    proceduralGenerator(currentPointX, currentPointY, nextPointX){
        this.createLowHill(currentPointX, currentPointY, nextPointX)
    }

    createLowHill(currentPointX, currentPointY, nextPointX){
        let nextPointY = null
        if(this.up == true){
            if(this.lowSlopeCoefficient < 12){
                this.lowSlopeCoefficient = this.lowSlopeCoefficient*1.03
            }
            nextPointY = this.nextPointY(currentPointX, currentPointY, nextPointX, Math.PI/this.lowSlopeCoefficient, "upwards")

            if(nextPointY < this.lowSlopeTop){
                this.up = false
                this.generateNewTop("LowHill")
            }
        } if (this.up == false){
            this.lowSlopeCoefficient = this.lowSlopeCoefficient*0.97
            nextPointY = this.nextPointY(currentPointX, currentPointY, nextPointX, Math.PI/-this.lowSlopeCoefficient, "downwards")
            if(nextPointY > this.canvasHeight -50){
                this.up = true
                this.lowSlopeCoefficient = 2
            }
        }
        this.points.push(new Point(nextPointX, nextPointY))

    }

    createMediumHill(currentPointX, currentPointY, nextPointX){

    }

    drawPath() {
        // This function draws the path to the screen that was generated by generatePath
        this.game_Environment.strokeStyle = "red";
        this.game_Environment.lineWidth = 3
        
        this.game_Environment.moveTo(this.points[0].x, this.points[0].y)
        this.game_Environment.beginPath();
        for(let i = this.points.length - 1; i > 0; i--){
            if(i-1 == 0){
                //Avoid getting index out of range
                break;
            }
            this.game_Environment.lineTo(this.points[i-1].x, this.points[i-1].y)
        }
        this.game_Environment.stroke()
    }   

    //Below are math formulas
    nextPointY(p1x, p1y, p2x, angle, direction){
        //Identifies the y-position of the next point (p2)
        let deltaHeight = 0
        let heightMultiplier = 1
        if(direction == "upwards"){
            deltaHeight = heightMultiplier*Math.sin(angle)*(p1x-p2x)
        } else if (direction == "downwards"){
            deltaHeight = heightMultiplier*Math.sin(angle)*(p1x-p2x)
        }
        let p2y = deltaHeight + p1y
        return p2y
    }

    increaseVelocity(){
        if(this.accelerationX < this.maxAcceleration){
            this.accelerationX += 0.2
            this.velocityX = this.accelerationX
        }
        this.updatePath()
    }

    applyFriction() {
        if(this.accelerationX > 0){
            this.accelerationX -= this.friction*this.accelerationX
            this.velocityX = this.accelerationX
        }

    }

    generateNewTop(hillType){
        if(hillType == "LowHill"){
            this.lowSlopeTop = Math.floor(Math.random() * (this.maxHeight - 100) + 100)
        }
    }
}